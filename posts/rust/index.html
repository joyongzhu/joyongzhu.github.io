<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Rust 解决所有权问题的几种方法 - Yong's Blog</title><meta name=Description content="This is my cool site"><meta property="og:title" content="Rust 解决所有权问题的几种方法"><meta property="og:description" content="什么是所有权 所有权是 Rust 中最重要的特性之一, 那么什么是所有权呢? 在一些开发语言如 Python 中，有 GC (垃圾回收机制)，这是语言本身提供的内存管理机制，而"><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/posts/rust/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-14T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-14T00:00:00+00:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust 解决所有权问题的几种方法"><meta name=twitter:description content="什么是所有权 所有权是 Rust 中最重要的特性之一, 那么什么是所有权呢? 在一些开发语言如 Python 中，有 GC (垃圾回收机制)，这是语言本身提供的内存管理机制，而"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://example.org/posts/rust/><link rel=prev href=http://example.org/posts/hugo%E4%BB%93%E5%BA%93%E8%AE%BE%E7%BD%AE%E4%B8%8E%E6%8E%A8%E9%80%811/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Rust 解决所有权问题的几种方法","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/example.org\/posts\/rust\/"},"genre":"posts","keywords":"Rust","wordcount":1848,"url":"http:\/\/example.org\/posts\/rust\/","datePublished":"2023-02-14T00:00:00+00:00","dateModified":"2023-02-14T00:00:00+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Yong"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Yong's Blog">Yong's Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/categories/documentation/>文档 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Yong's Blog">Yong's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/categories/documentation/ title>文档</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Rust 解决所有权问题的几种方法</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Yong</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-02-14>2023-02-14</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 1848 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 4 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#什么是所有权>什么是所有权</a></li><li><a href=#解决所有权的问题>解决所有权的问题</a><ul><li><a href=#在不需要完整所有权的地方使用引用>在不需要完整所有权的地方，使用引用</a></li><li><a href=#重构代码减少长存活期的值>重构代码，减少长存活期的值</a></li><li><a href=#在需要完整所有权的地方复制长存活期的值>在需要完整所有权的地方，复制长存活期的值</a></li><li><a href=#把数据包装到能帮助解决移动问题的类型中>把数据包装到能帮助解决移动问题的类型中</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=什么是所有权>什么是所有权</h2><p><strong>所有权</strong>是 Rust 中最重要的特性之一, 那么什么是所有权呢?</p><p>在一些开发语言如 Python 中，有 GC (<em><strong>垃圾回收机制</strong></em>)，这是语言本身提供的内存管理机制，而另一些语言如 C、C++ 则依赖开发人员手动管理内存。具有 GC 的语言大多存在性能问题，而依赖开发者手动管理内存的语言编写的程序往存在难以发现的内存问题，Rust 则使用了一种全新的思路：将内存管理的重担交给编译器，而<strong>所有权</strong>就是编译器用来管理内存的工具之一。</p><p>通俗地，便于理解地解释所有权：你租的房子，房东具有所有权，而你只有使用权，无论你如何折腾，都不能改变该房子的归属。</p><p>先来简单看个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_fn</span>(arg: <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;in:{}&#34;</span>, arg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span>    test_fn(i);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;out:{}&#34;</span>, i);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>in:32
</span></span><span style=display:flex><span>out:32
</span></span></code></pre></div><p>这么看是不是很正常，一个变量在传入函数之后仍然可以使用，这也符合我们在使用其他编程语言时的操作习惯。</p><p>再看下面的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>User</span> { <span style=color:#75715e>// 自定义一个结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    name: String,
</span></span><span style=display:flex><span>    age: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_user</span>(arg: <span style=color:#a6e22e>User</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;in:{:?}&#34;</span>, arg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> user1 <span style=color:#f92672>=</span> User {name: String::from(<span style=color:#e6db74>&#34;zzz&#34;</span>), age: <span style=color:#ae81ff>12</span>};
</span></span><span style=display:flex><span>    print_user(user1);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;out:{:?}&#34;</span>, user1);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>error<span style=color:#f92672>[</span>E0382<span style=color:#f92672>]</span>: borrow of moved value: <span style=color:#e6db74>`</span>user1<span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>  --&gt; src/main.rs:14:26
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span><span style=color:#ae81ff>12</span> |     let user1 <span style=color:#f92672>=</span> User <span style=color:#f92672>{</span>name: String::from<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;zzz&#34;</span><span style=color:#f92672>)</span>, age: 12<span style=color:#f92672>}</span>;
</span></span><span style=display:flex><span>   |         ----- move occurs because <span style=color:#e6db74>`</span>user1<span style=color:#e6db74>`</span> has type <span style=color:#e6db74>`</span>User<span style=color:#e6db74>`</span>, which does not implement the <span style=color:#e6db74>`</span>Copy<span style=color:#e6db74>`</span> trait
</span></span><span style=display:flex><span><span style=color:#ae81ff>13</span> |     print_user<span style=color:#f92672>(</span>user1<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>   |                ----- value moved here
</span></span><span style=display:flex><span><span style=color:#ae81ff>14</span> |     println!<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;out:{:?}&#34;</span>, user1<span style=color:#f92672>)</span>;
</span></span><span style=display:flex><span>   |                          ^^^^^ value borrowed here after move
</span></span></code></pre></div><p>Rust 有一个叫做 <code>Copy</code> trait 的特殊标注，可以用在类似整型这样的存储在栈上的类型上，如果一个类型实现了 <code>Copy</code> trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 标注，将会出现一个编译时错误。要学习如何为你的类型添加 <code>Copy</code> 标注以实现该 trait，请阅读附录 C 中的 <a href=https://rustwiki.org/zh-CN/book/appendix-03-derivable-traits.html target=_blank rel="noopener noreffer">“可派生的 trait”</a>。</p><p>那么哪些类型实现了 <code>Copy</code> trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 <code>Copy</code>，任何不需要分配内存或某种形式资源的类型都可以实现 <code>Copy</code> 。如下是一些 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li></ul><h2 id=解决所有权的问题>解决所有权的问题</h2><h3 id=在不需要完整所有权的地方使用引用>在不需要完整所有权的地方，使用引用</h3><p>一种常见的更改是降低所需的访问级别，如果我们不用所有权，那么就需要使用借用，对于只读可以使用 <strong>& T</strong>， 对于可写，则需要使用 <strong>& mut T</strong>。示例如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>User</span> { <span style=color:#75715e>// 自定义一个结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    name: String,
</span></span><span style=display:flex><span>    age: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_user</span>(arg: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>User</span>) {    <span style=color:#75715e>// 修改函数签名，传入一个引用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;in:{:?}&#34;</span>, arg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//fn print_user(arg: &amp;mut User) {    // 修改函数签名，传入一个可变引用
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    println!(&#34;in:{:?}&#34;, arg);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> user1 <span style=color:#f92672>=</span> User {name: String::from(<span style=color:#e6db74>&#34;zzz&#34;</span>), age: <span style=color:#ae81ff>12</span>};
</span></span><span style=display:flex><span>    print_user(<span style=color:#f92672>&amp;</span>user1);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;out:{:?}&#34;</span>, user1);    <span style=color:#75715e>// 传入引用后仍然可用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=重构代码减少长存活期的值>重构代码，减少长存活期的值</h3><p>一些长存活期的值，如全局变量等，尽可能重构代码，通过函数返回或者其他数据传递方式来将这些值的存活期压缩、拆散，让其离散且短暂的存在。</p><p>这么操作有两个好处：</p><ol><li>我们不必维护一个始终存活的对象了</li><li>可以把短存活期值的所有权转移到其他函数中，提高可管理性</li></ol><h3 id=在需要完整所有权的地方复制长存活期的值>在需要完整所有权的地方，复制长存活期的值</h3><p>合理使用 <strong>Copy</strong> 和 <strong>Clone</strong> 这两个 trait，以将需要长存活期的值复制。请参考 <a href="https://rustcc.cn/article?id=c3fc25cf-dab6-4b51-8547-1ff4aacbfc32" target=_blank rel="noopener noreffer">Copy 与 Clone trait 的区别与关联</a></p><h3 id=把数据包装到能帮助解决移动问题的类型中>把数据包装到能帮助解决移动问题的类型中</h3><p>众所周知，Python 是一种 GC 语言，而 GC（Garbage Collection，垃圾回收）的一个很重要的特性就是引用计数，程序通过判断值的引用计数来决定是否要回收内存，每当创建一个引用时，引用计数 +1，每当删除一个引用时，引用计数 -1，当引用计数为0时清理该值回收内存。</p><p>为了控制所有权，Rust 中也存在这种类型：Rc&lt;<strong>T</strong>>，其名称为 <strong>引用计数</strong>（<em>reference counting</em>）的缩写。</p><p>直接看例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::rc::Rc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> user1 <span style=color:#f92672>=</span> User {name: String::from(<span style=color:#e6db74>&#34;zzz&#34;</span>), age: <span style=color:#ae81ff>12</span>};
</span></span><span style=display:flex><span>    print_user(<span style=color:#f92672>&amp;</span>user1);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;out:{:?}&#34;</span>, user1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rc_value <span style=color:#f92672>=</span> Rc::new(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, rc_value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rc_value1 <span style=color:#f92672>=</span> rc_value.clone();
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, rc_value1);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意，Rc&lt;<strong>T</strong>> 不可变，并且只能在单线程中使用（如果要在多线程中使用引用计数，需要替换成Arc&lt;<strong>T</strong>>，这是一个原子引用计数）。如果我们要让其可变，需要再包装一层，使用Rc&lt;RefCell&lt;<strong>T</strong>&#187;，此类型支持内部可变性。</p><p>看以下例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::rc::Rc;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::cell::RefCell;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> user1 <span style=color:#f92672>=</span> User {name: String::from(<span style=color:#e6db74>&#34;zzz&#34;</span>), age: <span style=color:#ae81ff>12</span>};
</span></span><span style=display:flex><span>    print_user(<span style=color:#f92672>&amp;</span>user1);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;out:{:?}&#34;</span>, user1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rc_value <span style=color:#f92672>=</span> Rc::new(RefCell::new(<span style=color:#ae81ff>10</span>));
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;{:?}&#34;</span>, rc_value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> rc_value1 <span style=color:#f92672>=</span> rc_value.borrow_mut();
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>rc_value1 <span style=color:#f92672>+=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;{:?}&#34;</span>, rc_value);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Shell data-lang=Shell><span style=display:flex><span>RefCell <span style=color:#f92672>{</span> value: <span style=color:#ae81ff>10</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>RefCell <span style=color:#f92672>{</span> value: <span style=color:#ae81ff>20</span> <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>可以看到 rc_value 的值变化了。</p><p>使用引用计数需要注意的几点：</p><ul><li>在使用某一类型时，如果为此引入了引用计数功能，即把某个类型包装到其他类型中，这种操作通常会带来额外的运行时开销。</li><li>如果使用 Clone 后出现了高开销情况，此时使用 Rc&lt;<strong>T</strong>> 就是很方便的替代方案，这样就允许在两个位置共享所有权。</li></ul><p>参考资料:<br>[1] <a href=https://rustwiki.org/zh-CN/book/ch15-04-rc.html target=_blank rel="noopener noreffer"><code>Rc&lt;T></code> 引用计数智能指针 - Rust 程序设计语言</a><br>[2] 蒂姆 麦克纳马拉.Rust 实战[M].北京：人民邮电出版社，2022:114-129</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-02-14</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=http://example.org/posts/rust/ data-title="Rust 解决所有权问题的几种方法" data-hashtags=Rust><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=http://example.org/posts/rust/ data-hashtag=Rust><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=http://example.org/posts/rust/ data-title="Rust 解决所有权问题的几种方法"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=http://example.org/posts/rust/ data-title="Rust 解决所有权问题的几种方法"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=http://example.org/posts/rust/ data-title="Rust 解决所有权问题的几种方法"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/rust/>Rust</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/hugo%E4%BB%93%E5%BA%93%E8%AE%BE%E7%BD%AE%E4%B8%8E%E6%8E%A8%E9%80%811/ class=prev rel=prev title=Hugo仓库设置与推送><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Hugo仓库设置与推送</a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善</div><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.110.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Yong</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>